# Jan 2021, Monthly I Learned

## 1/1

### 모노레포

https://kdydesign.github.io/2020/08/25/mono-repo-lerna/
https://kdydesign.github.io/2020/08/27/mono-repo-lerna-example/

1. 멀티레포 vs 모노레포
   1. 멀: 여러repo에 각각 패키지 관리. A를 만드는데 B, C 레포로 나눠짐. CI가 하나에 집중하기 때문에 빠름. 컨플릭 피하기. But 공통된 설정 매번 다 세팅및 설치해야함. 공통코드도 중복됨. 그리구 이슈트래킹이나 로그가 분산되어 관리(결국 하나의 서비스 목푠데도). 의존성 버전관리 hell.
   2. 모: 여러패키지 한 repo에 관리. 공통코드나 설정 한벌만(각 의존성 업데이트도 관리 편함). 이슈 트래킹 통일. But repo가 넘 커지고 CI느림. 패키지별 과한 의존 관계.
2. 구글, 페북, 트위터가 모노레포 방식 선택
3. Lerna: 모노레포 관리와 workflow 최적화 도구
   1. 모듈 설치할때 중복을 통합해줌 / 독립적인 버전 정책 / 패키지 일괄 push및 npm publish
   2. Babel, vue-cli, jest, nuxt, cra, webpack-cli 등이 사용
   3. https://openbase.io/js/lerna <- 오홍 오픈소스 현황 대시보드구나

## 1/2

https://speakerdeck.com/raon0211/toseuyi-maikeuropeuronteuendeu-akitegceo-geurigo-jadonghwa
https://aws.amazon.com/ko/microservices/
https://medium.com/@yesesyo/%EA%B0%80%EB%B3%8D%EA%B2%8C-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B5%AC%EC%B6%95%ED%95%B4%EB%B3%B4%EA%B8%B0-1-fb4d7741b316

### 마이크로서비스

1. 여러 서비스를 관리하기 위해...
   - v1 모놀리식: 한패키지에 여러서비스 (빌드느림, 서비스별 캐싱 등 정책분리 어려움). 뚱뚱해지면 새로운 아이디어 구현 어려워짐.
   - v2 마이크로서비스: 한패키지에 하나서비스, 자유로운 의존성 선택
   - v3 모노레포: 한repo에 여러패키지
2. 장점
   - 설정공유 간편하다 (eslint 세팅을 상대경로로 상위에서 받아오기(`extends: [../../.eslintrc.service.js`))
   - 소규모 컨텍스트의 작은 팀:민첩하다. 서비스별로 독립적인 확장. 기술적 자유, 배포쉬움.

## 1/3

### Observable

https://slides.com/seokjume/observable#/1-title (옵저버블을 읽기 좋은 도해로 표현한 좋은 자료다. debounce 타임 안에서 이벤트 구독해제가 어떻게 일어나는지 그림에서 감탄)

1. Promise의 한계: 취소불가(e.g. 검색 자동완성때 텍스트를 바꿀때마다 이전 텍스트 자동완성콜 취소해야한다), 단일값
2. Observable
   - 비동기로 발생하는 '여러'데이터를 다루는 인터페이스 / 이벤트 스트림 / 취소 가능 / 흐름을 쉽게 읽을 수 있음
   - cleanup 함수 제공: 이벤트리스터 해지 or ajax abort
   - composition 가능
   - 아하 이벤트 스트림을 함수형으로 다룰 수 있구나. 성능차이는 어떻게 되나?
3. js에선 아직 proposal(stage1)상태. RxJs등이 옵저버블 구현체 제공해서 사용가능.

## 1/4

### ECMAScript와 TC39

https://ahnheejong.name/articles/ecmascript-tc39/
https://ko.wikipedia.org/wiki/Ecma_%EC%9D%B8%ED%84%B0%EB%82%B4%EC%85%94%EB%84%90

1. Netscape와 MS등 이해당사자들끼리 합의해서 ECMAScript 언어 표준 만듦.
   1. (Ecma인터네셔널: 정보통신 국제적 표준화기구. European Computer Manufactures Association이었다가 국제적 확장위해 이름 바꿈)
   2. (Ecma인터네셔널의 여러 기술위원회(TC - Technial Committee)중 TC39란 위원회(모질라, 구글, 애플 등 브라우저 벤더, 페북, 트위터 등 다양한 단체 피플)가 이 명세 관리)
   3. TC39위원회 [회의록](https://github.com/tc39/notes) 흥미롭다. 2020년 11월 19일 회의 보면 `::` 문법 [프로포절](https://github.com/hax/proposal-extensions) 이랑 이에 대한 [프레젠테이션](http://johnhax.net/2020/tc39-nov-ext/slide#0), 그리고 이에 대한 구루들의 [열띤 토론](https://github.com/tc39/notes/blob/master/meetings/2020-11/nov-19.md)이 모두 적혀있군.
      1. 회의에서 발제자의 발표가 끝나고 제일 처음에 말을 꺼낸 MM이란 사람 말 전개 구조가 인상깊다. 디테일하게 칭찬하고 감사를 표하고, 스무스하게 질문으로 들어간다.
         1. 프로포절 감사하다 / 이게 stage one 가길 완전 협조하겠다 / 훌륭한 발견이다 / very simple core가 있는 발표다. 적절한 starting point를 잡았어 / bind오퍼레이터에 대한 virtual한 관점. / 글고 니가 simple코어로 좁히기 전에 broader exploration을 얘기해서 우리가 대안도 상상할수있게 해서 좋다. 전체적으로 맘에 든다. / 이제 3항폼에 대해 질문 있다 ,~~
      2. 영어로 회의 진행할 때 참고할 수 있는 표현과 전개방식이 많다. 전 회사에서 알았다면 유용했겠네.
2. TC39 프로세스
   1. 프로포절 저장소: https://github.com/tc39/proposals
      1. 문법을 제안한다는게 재밌다. 라이브러리 만드는 그 이상이다. https://github.com/tc39/proposal-top-level-await
   2. 0단계: 누구든 프로포절을 낼 수 있음. 라이센스 동의 + TC39컨트리뷰터로 등록. 모두가 Tc39 회의 안건으로 상정됨.
   3. 1단계: TC39구성원 중 1인이 총대매줘야함(챔피언). 구현상 폴리필, 데모 등 필요.
   4. 2단계: ECMAScript표준으로 작성된 초안 필요. 실제 표준 편입될 때 사용할 명세의 초기버전.
   5. 3단계: 마무리된 명세 필요. 이제부턴 변경 불가
   6. 4단계: 제안 수락됨! 다음 표준 발표를 기다리는 중.

## 1/5

### 명령형(imperative)과 선언형(declarative) 프로그래밍

https://so-tired.tistory.com/75
https://boxfoxs.tistory.com/430 <- 앗 ㅅㄹ님
https://dev.to/khophi/explain-declarative-vs-imperative-programming-like-i-m-5-2a1l

```jsx
// option 1
<button onClick={() => logToServer(data)} />

// option 2
<LoggingClick data={data}>
  <button />
</LoggingClick>
```

option 1보다는 option2가 더 코드가 깔끔하다. 선언적이니까~ 라고 말하려다가 내가 명령형과 선언형의 차이를 모호하게만 인지하고 있다는걸 깨닫고 좀 찾아봤다.

- 리액트 컨셉 자체가 선언형
  - jQuery등: 상태에 따라 DOM을 어떻게 업데이트 해야하는지 규칙을 적기
  - 리액트: 상태에 따라 보여져야하는 DOM을 미리 정의 (매번 새로그리기 - Virtual DOM 으로 빠른계산해서 가능한 일)
- 명령형 vs 선언형
  - 명령형: '어떻게' 할것인가 (e.g. 12번 테이블이 4인자리가 비어있네요 저기로 걸어가 앉겠습니다)
  - 선언형: '무엇을' 할것인가 (e.g. 4인 앉을자리를 주세요)
    - 다만 종업원이 가는길 알고있어야함('어떻게'에 대한 추상화): 선언형 프로그래밍의 중요한 솔루션! 명령형으로 작성된 구현에 대한 추상화

### 언제 useCallback 을 쓰고, 쓰지 말아야 할까?

https://dmitripavlutin.com/dont-overuse-react-usecallback/
https://aheadcreative.co.uk/articles/when-to-use-react-usecallback/
https://kentcdodds.com/blog/usememo-and-usecallback

> '이 함수 useCallback으로 감싸주세요~'란 코드리뷰 많이들 받아봤을거임. 과연 효과적인 useCallback의 유즈케이스는?

1. 써야 할 때: React.memo로 만든 컴포넌트에 함수 넘길 때 / 다른 훅에 dependency로 있을때 / 너무 긴 함수(웬만하면 안 만드는게 좋겠지만)
2. 안써도 될 때: 위 케이스가 아닐 때.(useCallback을 부르는 코스트와 함수를 memo해서 얻는 성능향상이 비슷. useCallback dependencies 관리포인트만 늘어날수도)
   1. 아래와 같은 케이스는 useCallback 없는게 성능 더 빠름 (useCallback도 불러야하고 빈 array도 만들어야하고.)
   ```js
   const dispense = React.useCallback((candy) => {
     setCandies((allCandies) => allCandies.filter((c) => c !== candy));
   }, []);
   ```
   - 미미한 성능최적화보다 코드를 복잡하게 만든다는 단점이 더 커짐.
   - 유지보수 하다 dependencies array 에 실수할수도 있음
3. useCallback은 계산된 값을 메모이즈하는게 아니다. 함수 자체를 메모이즈하는것임. 값 메모가 필요하면 useMemo쓰삼.
4. 결론: 성능최적화는 꽁짜가 아니다. 최적화를 하고 싶다면 실제로 최적화가 된지 측정해보라.

### 독서 습관을 만드는 구체적인 방법

https://blog.shiren.dev/2020-10-05/

1. 책읽는 속도파악: 100페이지에 몇분 걸리는지 측정. 후에는 책 집었을 때 '흠 대략 n시간 걸리겠군' 파악가능 (shiren님은 약 1시간)
2. 마킹하며 읽기 - 종이책이라면 손가락으로 가리켜서 사진찍고 구글포토에 그룹으로 만들어두기(OCR로 검색도 됨!)
3. 마킹한 부분 따로 정리

## 1/6

### React clean code

https://dev.to/jithinks97/writing-clean-react-code-2mcm

1. 컴포넌트는 짧짧익선
2. 컴포넌트에서는 같은 레벨의 추상화를 모아둬라
3. props갯수 줄이기. 많이 보내야한다면 비슷한 인자를 object로 묶어서.

## 1/7

### 웹소켓이 등장하기까지 - 폴링, 스트리밍, 웹소켓

https://lkhlkh23.tistory.com/121
https://ko.javascript.info/websocket
https://medium.com/@chullino/http%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-websocket%EA%B9%8C%EC%A7%80-94df91988788

1. Polling: 클라에서 api 주기적 요청. 요청수가 많아 서버부담 큼.
2. Long Polling: 클라에서 api 요청하면 서버에선 대기타다가 필요한 시점에 응답값 줌. 서버 요청이 몰려서 순간 부담 커질수 있다.
3. Streaming: 연결 안 끊고 계속 전달.
4. WebSocket: 새로운 통신 프로토콜.첨에 HTTP로 연결했다가 서로 쿵짝이 맞으면 그 때 부터 HTTP프로토콜이 아닌 양방향 통신 가능.

   ```js
   let socket = new WebSocket("wss://javascript.info"); // ws보다 wss가 안전. https처럼.
   socket.onopen = function (e) {
     alert("커넥션 만들어짐");
     socket.send("데이터 가랏");
   };

   socket.onmessage = function (e) {
     alert("서버가 준 데이터:", e.data);
   };

   socket.onclose = function (e) {
     if (e.wasClean) {
       alert("정상종료");
     } else {
       alert("커넥션 이상하게 쥬금");
     }
   };

   socket.onerror = function (e) {
     alert("에러", e);
   };
   ```

5. HTTP 프로토콜: url 주면 서버에서 문서 줄수이음
6. AJAX: HTTP프로토콜을 잘 활용. XMLHttpRequest 객체로 데이터 주고받음.
7. WebSocket 프로토콜: 양방향 프로토콜

## 1/8

### HTML5, 웹소켓

https://www.slideshare.net/hiscale/111015-html5-1
2011년 자료.

1. HTTP: Hyper Text Transfer Protocol. 서버가 HTML로 디자인된 문서를 유저에게 잘 보내주는게 핵심. 이전까진 걍 터미널에서 txt만 주고받음.
   1. 그래서 새페이지에서 새데이터 보여주거나, 팝업 / iframe으로 보여줌. 플래시나 액티브엑스도 사용.
2. Ajax: Asyncronous JavaScript And XML. 옛날부터 존재하던 기법이지만 구글이 쓰며 대중화됨. js의 XMLHttpRequest란 api로 url이동이 아닌 임의 요청을 주고받음.
   1. XMLHttpRequest의 한계. 브라우저가 서버로 요청 보내면 서버가 응답 주는것만 가능. 서버가 필요할 때 먼저 데이터를 주는게 불가능.
3. 웹소켓: HTML5 표준에 추가된 규약. 어제 적은 설명과 동일.

## Inbox

- 자동로깅 https://github.com/ankane/ahoy.js/
- 팩토리 https://github.com/willryan/factory.ts
- postcss
- 마이크로서비스
- 토보파pc 새 서비스 스캐폴딩 방법
- AWS Lambda
- html5 https://www.slideshare.net/hiscale/111015-html5-1
- 네이버 fe 읽을거리 https://github.com/naver/fe-news/blob/master/issues/2021-01.md
